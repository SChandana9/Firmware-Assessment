Q-1 Switch & LED Blinking 
The LED is off initially. Depending on switch press, the LED blinks in
following way.
1st Switch press: LED blinks at frequency of 0.5 Hz.

2nd Switch press: LED blinks at frequency of 1 Hz.

3rd Switch press: LED blinks at frequency of 2 Hz.

4th Switch press: LED turns off.

5th Switch press: considered 1st switch press and the LED blinking cycle repeats.

program-1:

#include <stdio.h>
#include <unistd.h>   
#include <termios.h>  
#include <fcntl.h>    

// Function to check if the Enter key is pressed
int buttonpressed() {
    struct termios oldt, newt;
    int ch;
    int oldf;

    // Get the terminal settings for stdin
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);

    ch = getchar();

    // Restore old settings
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    fcntl(STDIN_FILENO, F_SETFL, oldf);

    return (ch == '\n') ? 1 : 0;  // Return 1 if Enter is pressed
}

int main() {
    int buttoncount = 0;
    int led_on = 0;
    unsigned int delaytime = 0;  

    printf("Press Enter to change LED blinking frequency:\n");

    while (1) {
        // Check if Enter key is pressed
        if (buttonpressed()) {
            buttoncount = (buttoncount % 4) + 1;  // Cycle through button presses

            switch (buttoncount) {
                case 1:
                    delaytime = 1000000; // 0.5 Hz -> 1 second delay
                    printf("LED blinking at 0.5 Hz\n");
                    break;
                case 2:
                    delaytime = 500000;  // 1 Hz -> 0.5 second delay
                    printf("LED blinking at 1 Hz\n");
                    break;
                case 3:
                    delaytime = 250000;  // 2 Hz -> 0.25 second delay
                    printf("LED blinking at 2 Hz\n");
                    break;
                case 4:
                    delaytime = 0;       // LED OFF
                    printf("LED is OFF\n");
                    break;
            }
        }

        // Handle LED blinking if delay is set
        if (delaytime > 0) {
            led_on = !led_on;  // Toggle LED state
            printf("LED %s\n", led_on ? "ON" : "OFF");
            usleep(delaytime);
        }
    }

    return 0;
}



Q-2 C program in an online compiler,
1. Use timer to simulate data generated by external sensor. Setup the timer to trigger every
second and generates random number (0 to 5) of random bytes and adds this to a globally
accessible data structure.
2. Separately wake up periodically (every 10s), checks if 50 bytes are stored in the globally
accessible data structure and prints only the latest 50 bytes (in hex value) and deletes the
printed bytes from the data structure.
3. For example, 1st second 4 bytes are added, 2nd second 3 bytes are added and 10th
second there are 39 bytes are in the buffer. Thus at 10th second data is not printed. At 20th
second, if there are more than 50 bytes in the buffer, the main thread only prints the latest
50 bytes and deletes them.

//program-2

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>  

#define BUFFER_SIZE 100  // Buffer size for storing sensor data
#define MINBYTES 50 // Minimum bytes required for processing

unsigned char sensorData[BUFFER_SIZE];  // Global buffer for sensor data
int dataIndex = 0;  // Index to track stored data

// Function to simulate sensor data generation
void generateSensorData() {
    int numBytes = rand() % 6;  // Generate 0 to 5 random bytes
    
    printf("Generated %d bytes: ", numBytes);
    for (int i = 0; i < numBytes; i++) {
        if (dataIndex < BUFFER_SIZE) {  // Ensure buffer does not overflow
            sensorData[dataIndex] = rand() % 256;  // Generate a random byte (0-255)
            printf("%02X ", sensorData[dataIndex]);  // Print in hex format
            dataIndex++;
        }
    }
    printf("\n");
}

// Function to process and remove the latest 50 bytes from the buffer
void processSensorData() {
    if (dataIndex >= MINBYTES) {  // Check if we have at least 50 bytes
        printf("\nProcessing latest 50 bytes: ");
        
        // Print the latest 50 bytes
        for (int i = dataIndex - MINBYTES; i < dataIndex; i++) {
            printf("%02X ", sensorData[i]);  // Print in HEX
        }
        printf("\n");

        // Remove the processed bytes by shifting remaining data
        int remainingBytes = dataIndex - MINBYTES;
        for (int i = 0; i < remainingBytes; i++) {
            sensorData[i] = sensorData[i + MINBYTES];
        }
        
        dataIndex = remainingBytes;  // Update the new index position
        printf("50 bytes processed and removed. Remaining bytes in buffer: %d\n\n", dataIndex);
    }
}

int main() {
    srand(time(NULL));  // Initialize random seed

    printf("Starting sensor data simulation...\n");

    int elapsedTime = 0;  // Track elapsed time in seconds

    while (1) {  // Infinite loop to simulate continuous operation
        generateSensorData();
        sleep(1);  // Wait for 1 second

        elapsedTime += 1;
        if (elapsedTime % 10 == 0) {  // Every 10 seconds, process data
            processSensorData();
        }
    }

    return 0;
}
